{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Relic","title":"Relic"},{"location":"#relic","text":"","title":"Relic"},{"location":"agg/","text":":agg Relic provides a means to group rows and run aggregations on them. This analogous to SQL GROUP BY . Form stmt = [ :agg cols & bindings ] cols = [ & col ] binding = [ new-col agg-expr ] agg-expr = agg-fn| [ agg-fn & args ] Example [[ :from :A ] [ :agg [ :a ] [ :n [ rel/sum :b ]] [ :n2 [ rel/avg :b ]] [ :c count ]] See also: aggregates for aggregate functions.","title":":agg"},{"location":"agg/#agg","text":"Relic provides a means to group rows and run aggregations on them. This analogous to SQL GROUP BY .","title":":agg"},{"location":"agg/#form","text":"stmt = [ :agg cols & bindings ] cols = [ & col ] binding = [ new-col agg-expr ] agg-expr = agg-fn| [ agg-fn & args ]","title":"Form"},{"location":"agg/#example","text":"[[ :from :A ] [ :agg [ :a ] [ :n [ rel/sum :b ]] [ :n2 [ rel/avg :b ]] [ :c count ]] See also: aggregates for aggregate functions.","title":"Example"},{"location":"aggregates/","text":"Aggregates The :agg statement permits the use of aggregate functions, such as count, sum and so on. See below for a listing of what you can do. Stats max the max val by some expr . min the min val by some expr . rel/max-by the max row by some expr . rel/min-by the min row by some expr . Top or bottom N rel/bottom find the lowest n vals for some expr . rel/bottom-by find the lowest n rows for some expr . rel/top find the biggest n vals for some expr . rel/top-by find the biggest n rows for some expr . Counts count row count, or row count for all rows meeting some predicate . rel/count-distinct val count for all distinct vals of some expr . Other rel/any / rel/not-any check if any row meets a predicate (or not)","title":"Aggregates"},{"location":"aggregates/#aggregates","text":"The :agg statement permits the use of aggregate functions, such as count, sum and so on. See below for a listing of what you can do. Stats max the max val by some expr . min the min val by some expr . rel/max-by the max row by some expr . rel/min-by the min row by some expr . Top or bottom N rel/bottom find the lowest n vals for some expr . rel/bottom-by find the lowest n rows for some expr . rel/top find the biggest n vals for some expr . rel/top-by find the biggest n rows for some expr . Counts count row count, or row count for all rows meeting some predicate . rel/count-distinct val count for all distinct vals of some expr . Other rel/any / rel/not-any check if any row meets a predicate (or not)","title":"Aggregates"},{"location":"any/","text":"rel/any An aggregate function that tests if for any row in the group (pred row) returns truthy, accepts a expr as an arg. e.g ;; :has-a will be true if any row has a truthy `:a` col [[ :from :A ] [ :agg [] [ :has-a [ rel/any :a ]]]","title":"any"},{"location":"any/#relany","text":"An aggregate function that tests if for any row in the group (pred row) returns truthy, accepts a expr as an arg. e.g ;; :has-a will be true if any row has a truthy `:a` col [[ :from :A ] [ :agg [] [ :has-a [ rel/any :a ]]]","title":"rel/any"},{"location":"avg/","text":"rel/avg An aggregate function that computes the average for all sampled values by some expr [[ :from :Orders ] [ :agg [] [ :aov [ rel/avg :total ]]]","title":"avg"},{"location":"avg/#relavg","text":"An aggregate function that computes the average for all sampled values by some expr [[ :from :Orders ] [ :agg [] [ :aov [ rel/avg :total ]]]","title":"rel/avg"},{"location":"bottom-by/","text":"rel/bottom-by An aggregate function that returns the lowest n rows by some expr . [[ :from :A ] [ :agg [] [ :lowest-5a [ rel/bottom-by 5 :a ]]]]","title":"bottom-by"},{"location":"bottom-by/#relbottom-by","text":"An aggregate function that returns the lowest n rows by some expr . [[ :from :A ] [ :agg [] [ :lowest-5a [ rel/bottom-by 5 :a ]]]]","title":"rel/bottom-by"},{"location":"bottom/","text":"rel/bottom An aggregate functions that returns the lowest n values for some expr across the group. [[ :from :A ] [ :agg [] [ :lowest-5a [ rel/bottom 5 :a ]]]]","title":"bottom"},{"location":"bottom/#relbottom","text":"An aggregate functions that returns the lowest n values for some expr across the group. [[ :from :A ] [ :agg [] [ :lowest-5a [ rel/bottom 5 :a ]]]]","title":"rel/bottom"},{"location":"btree/","text":":btree","title":":btree"},{"location":"btree/#btree","text":"","title":":btree"},{"location":"change-tracking/","text":"","title":"Change tracking"},{"location":"check/","text":":check","title":":check"},{"location":"check/#check","text":"","title":":check"},{"location":"const/","text":":const Provides a constant collection as a relation. Examples [[ :const [{ :a 1 } { :a 2 } { :a 3 }]]]","title":":const"},{"location":"const/#const","text":"Provides a constant collection as a relation.","title":":const"},{"location":"const/#examples","text":"[[ :const [{ :a 1 } { :a 2 } { :a 3 }]]]","title":"Examples"},{"location":"constrain/","text":":constrain","title":":constrain"},{"location":"constrain/#constrain","text":"","title":":constrain"},{"location":"constraints/","text":"Constraints Constraints are just relvars ending in one of the constraint statements :unique , :fk and :check . These operators throw typically exceptions when the constraints are not met. To constrain a database, you materialize constraint relvars (and they can be removed with dematerialize ). Constraints can apply to any relvar, so you can apply constraints to derived relvars and joins, here is the obligatory order can have at most 10 items if its associated customer is called bob and its tuesday constraint. [[ :from Order ] [ :join Customer { :customer-id :customer-id }] [ :where [ = \"bob\" :firstname ] [ tuesday? [ ::rel/env :now ]]] [ :check { :pred [ <= [ count :items ] 10 ] , :error [ str \"order can have at most 10 items if its associated customer is called bob and its tuesday, found: \" [ count :items ]]}]] As it is convenient to specify multiple constraints on a relvar in one form, a special :constrain statement is provided. e.g [[ :from Customer ] [ :constrain [ :check [ string? :firstname ] [ string? :lastname ] [ nat-int? :age ]] [ :unique :customer-id ] [ :fk Address { :address-id :address-id }]]] Constraint operators :check ensure certain predicates hold :req ensure cols exist :fk ensure a referenced row exists in some other relvar :constrain combine multiple constraints on a relvar :unique unsure only one row exists for some set of expressions","title":"Overview"},{"location":"constraints/#constraints","text":"Constraints are just relvars ending in one of the constraint statements :unique , :fk and :check . These operators throw typically exceptions when the constraints are not met. To constrain a database, you materialize constraint relvars (and they can be removed with dematerialize ). Constraints can apply to any relvar, so you can apply constraints to derived relvars and joins, here is the obligatory order can have at most 10 items if its associated customer is called bob and its tuesday constraint. [[ :from Order ] [ :join Customer { :customer-id :customer-id }] [ :where [ = \"bob\" :firstname ] [ tuesday? [ ::rel/env :now ]]] [ :check { :pred [ <= [ count :items ] 10 ] , :error [ str \"order can have at most 10 items if its associated customer is called bob and its tuesday, found: \" [ count :items ]]}]] As it is convenient to specify multiple constraints on a relvar in one form, a special :constrain statement is provided. e.g [[ :from Customer ] [ :constrain [ :check [ string? :firstname ] [ string? :lastname ] [ nat-int? :age ]] [ :unique :customer-id ] [ :fk Address { :address-id :address-id }]]]","title":"Constraints"},{"location":"constraints/#constraint-operators","text":":check ensure certain predicates hold :req ensure cols exist :fk ensure a referenced row exists in some other relvar :constrain combine multiple constraints on a relvar :unique unsure only one row exists for some set of expressions","title":"Constraint operators"},{"location":"count-distinct/","text":"rel/count-distinct","title":"count-distinct"},{"location":"count-distinct/#relcount-distinct","text":"","title":"rel/count-distinct"},{"location":"count/","text":"count","title":"count"},{"location":"count/#count","text":"","title":"count"},{"location":"delete-exact/","text":":delete-exact","title":":delete-exact"},{"location":"delete-exact/#delete-exact","text":"","title":":delete-exact"},{"location":"delete/","text":":delete","title":":delete"},{"location":"delete/#delete","text":"","title":":delete"},{"location":"difference/","text":":difference Set difference Examples [[ :difference :a :b :c :d ]]","title":":difference"},{"location":"difference/#difference","text":"Set difference","title":":difference"},{"location":"difference/#examples","text":"[[ :difference :a :b :c :d ]]","title":"Examples"},{"location":"env/","text":"The environment","title":"Environment"},{"location":"env/#the-environment","text":"","title":"The environment"},{"location":"expand/","text":":expand Provides a means of flattening trees. Examples ( rel/q db Order ) ;; => # {{ :customer-id 42 , :items [{ :product 1 , :quantity 2 } , { :product 2 , :quantity 1 }]}} ;; => ( def OrderItem [[ :from :Order ] [ :expand [[ :product :quantity ] :items ]] [ :without :items ]]) ( rel/q db OrderItem ) ;; => # {{ :customer-id 42 , :product 1 , :quantity 2 } , { :customer-id 42 , :product 2 , :quantity 1 }}","title":":expand"},{"location":"expand/#expand","text":"Provides a means of flattening trees.","title":":expand"},{"location":"expand/#examples","text":"( rel/q db Order ) ;; => # {{ :customer-id 42 , :items [{ :product 1 , :quantity 2 } , { :product 2 , :quantity 1 }]}} ;; => ( def OrderItem [[ :from :Order ] [ :expand [[ :product :quantity ] :items ]] [ :without :items ]]) ( rel/q db OrderItem ) ;; => # {{ :customer-id 42 , :product 1 , :quantity 2 } , { :customer-id 42 , :product 2 , :quantity 1 }}","title":"Examples"},{"location":"expr/","text":"Expressions As relic supports conditions and computation via various relvar statements, it needs to support a form of computation expression. Your options are: use clojure functions use relic expressions Where you can use expressions: :where conditions :extend extensions :select projections :expand expansions :join / :left-join clauses :agg certain aggregates accept expressions as args (e.g sum ) :hash indexed expressions :btree indexed expressions clojure functions Clojure functions are fully supported by relic, and it is a major design goal to be able to drop to Clojure to do arbitrary ( pure! ) computation. n.b functions must be referentially transparent, or you risk glitches ;; you can use any function as an expression ( defn my-pred? [{ :keys [ foo ]}] ( = foo 42 )) [[ :from :A ] [ :where my-pred? ]] ;; in clojure you can use symbols if you want. [[ :from :A ] [ :where ` my-pred? ]] ;; same rules apply to computing columns ( defn compute-bar [{ :keys [ foo ]}] ( inc foo )) [[ :from :A ] [ :extend [ :bar compute-bar ]] [[ :from :A ] [ :select [ :bar compute-bar ]] ;; and expansions ( defn compute-baz-seq [{ :keys [ foo ]}] ( range foo )) [[ :from :A ] [ :expand [ :baz compute-baz-seq ]] relic expressions For convenience, and some extra goodies - an expression dsl is provided that lets you do simple computations 'inline', provides better ergonmics as you are working with rows 100% of the time, and allows for some extra goodies like sub queries, nil safe function application and so on. Mostly the execution semantics are similar to clojure, but vectors are used for calls over lists, and keywords are substituted for lookups. The goal is to avoid quote/unquote template shenanigans, and help make programming relic easier for simple cases that don't need a unique clojure function. ;; calls are vectors, `:foo` will be substituted with `(:foo row)` [[ :from :A ] [ = :foo 42 ]] ;; non-functions/non-keywords/non-vectors are just treated as constants [[ :from :A ] [ :where true ]] ;; bare keywords are tested against the row `(:foo row)` [[ :from :A ] [ :where :foo ]] ;; expressions can nest [[ :from :A ] [ :where [ = 42 [ inc [ dec :foo ]]]]] ;; special conditional forms are provided [[ :from :A ] [ :select [ :msg [ :if [ = 42 :foo ] \"the answer\" \"not the answer\" ]]]] [[ :from :A ] [ :where [ :and :foo :bar ]]] [[ :from :A ] [ :where [ :or :foo :bar ]]] ;; you can get the row with :% [[ :from :A ] [ = 10 [ count :% ]]] ;; you can reference non-keyword keys with ::rel/get [[ :from :A ] [ :where [ ::rel/get \"foo\" ]]] ;; you can escape vectors / keywords with :_ [[ :from :A ] [ :where [ = [ :_ :bar ] :foo ]]] ;; you can reference the env (see env.md) [[ :from :A ] [ :where [ = :foo [ ::rel/env :foo ]]]] ;; you can issue sub queries with :$1 (first row) and :$ (all rows) (see sub-queries.md) [[ :from :A ] [ :where [ :$1 :B { :a-id :a-id }]]] ;; nil safe calls with :? [[ :from :A ] [ :where [ :? str/includes? :foo :bar ]]] ;; expressions have extra exception handling logic, if you cannot afford this, use the unsafe modifier. [[ :from :A ] [ :where [ :! str/includes? :foo :bar ]]]","title":"Expressions"},{"location":"expr/#expressions","text":"As relic supports conditions and computation via various relvar statements, it needs to support a form of computation expression. Your options are: use clojure functions use relic expressions Where you can use expressions: :where conditions :extend extensions :select projections :expand expansions :join / :left-join clauses :agg certain aggregates accept expressions as args (e.g sum ) :hash indexed expressions :btree indexed expressions","title":"Expressions"},{"location":"expr/#clojure-functions","text":"Clojure functions are fully supported by relic, and it is a major design goal to be able to drop to Clojure to do arbitrary ( pure! ) computation. n.b functions must be referentially transparent, or you risk glitches ;; you can use any function as an expression ( defn my-pred? [{ :keys [ foo ]}] ( = foo 42 )) [[ :from :A ] [ :where my-pred? ]] ;; in clojure you can use symbols if you want. [[ :from :A ] [ :where ` my-pred? ]] ;; same rules apply to computing columns ( defn compute-bar [{ :keys [ foo ]}] ( inc foo )) [[ :from :A ] [ :extend [ :bar compute-bar ]] [[ :from :A ] [ :select [ :bar compute-bar ]] ;; and expansions ( defn compute-baz-seq [{ :keys [ foo ]}] ( range foo )) [[ :from :A ] [ :expand [ :baz compute-baz-seq ]]","title":"clojure functions"},{"location":"expr/#relic-expressions","text":"For convenience, and some extra goodies - an expression dsl is provided that lets you do simple computations 'inline', provides better ergonmics as you are working with rows 100% of the time, and allows for some extra goodies like sub queries, nil safe function application and so on. Mostly the execution semantics are similar to clojure, but vectors are used for calls over lists, and keywords are substituted for lookups. The goal is to avoid quote/unquote template shenanigans, and help make programming relic easier for simple cases that don't need a unique clojure function. ;; calls are vectors, `:foo` will be substituted with `(:foo row)` [[ :from :A ] [ = :foo 42 ]] ;; non-functions/non-keywords/non-vectors are just treated as constants [[ :from :A ] [ :where true ]] ;; bare keywords are tested against the row `(:foo row)` [[ :from :A ] [ :where :foo ]] ;; expressions can nest [[ :from :A ] [ :where [ = 42 [ inc [ dec :foo ]]]]] ;; special conditional forms are provided [[ :from :A ] [ :select [ :msg [ :if [ = 42 :foo ] \"the answer\" \"not the answer\" ]]]] [[ :from :A ] [ :where [ :and :foo :bar ]]] [[ :from :A ] [ :where [ :or :foo :bar ]]] ;; you can get the row with :% [[ :from :A ] [ = 10 [ count :% ]]] ;; you can reference non-keyword keys with ::rel/get [[ :from :A ] [ :where [ ::rel/get \"foo\" ]]] ;; you can escape vectors / keywords with :_ [[ :from :A ] [ :where [ = [ :_ :bar ] :foo ]]] ;; you can reference the env (see env.md) [[ :from :A ] [ :where [ = :foo [ ::rel/env :foo ]]]] ;; you can issue sub queries with :$1 (first row) and :$ (all rows) (see sub-queries.md) [[ :from :A ] [ :where [ :$1 :B { :a-id :a-id }]]] ;; nil safe calls with :? [[ :from :A ] [ :where [ :? str/includes? :foo :bar ]]] ;; expressions have extra exception handling logic, if you cannot afford this, use the unsafe modifier. [[ :from :A ] [ :where [ :! str/includes? :foo :bar ]]]","title":"relic expressions"},{"location":"extend/","text":":extend Computes new columns by binding the results of expressions . If the binding collides with an existing column, the existing column is overwritten. Accepts multiple extension forms, each a pair [binding expr] . The binding determines how the result should be added to the row: a column (keyword), just overwrite or add the column to the row a collection, assume the result is a map, and select-keys the collection and merge into the row. the special keyword :* , merge the entire result into the row. Form extend = [ :extend & extension ] extension = [ binding expr ] binding = col | [ & col ] | :* See expression reference for more information on expressions. Examples [[ :from :Customer ] [ :extend [ :fullname [ str :firstname \" \" :lastname ]]]] ( def TotalSpend [[ :from :Order ] [ :agg [ :customer-id ] [ :total-spend [ rel/sum :total ]]]]) Sub queries with :$1 and :$ ;; $1 to sub select another row, i.e an implicit left-join. ( def CustomerStats [[ :from :Customer ] [ :extend [[ :total-spend ] [ :$1 TotalSpend { :customer-id :customer-id }]]]]) ;; would result in a relation something like: # {{ :customer 42 , :total-spend 340.0 M }} ;; $1 to bind rows from another query to a column ( def Order [[ :from :Order ] [ :extend [ :items [ :$ OrderItem { :order-id :order-id }]]]]) ;; would result in a relation something like: # {{ :customer-id 42 , :total 340.0 M :items # {{ :product-id 43 , :quantity 1 } ... }} See also :select :agg Unsafe transformation","title":":extend"},{"location":"extend/#extend","text":"Computes new columns by binding the results of expressions . If the binding collides with an existing column, the existing column is overwritten. Accepts multiple extension forms, each a pair [binding expr] . The binding determines how the result should be added to the row: a column (keyword), just overwrite or add the column to the row a collection, assume the result is a map, and select-keys the collection and merge into the row. the special keyword :* , merge the entire result into the row.","title":":extend"},{"location":"extend/#form","text":"extend = [ :extend & extension ] extension = [ binding expr ] binding = col | [ & col ] | :* See expression reference for more information on expressions.","title":"Form"},{"location":"extend/#examples","text":"[[ :from :Customer ] [ :extend [ :fullname [ str :firstname \" \" :lastname ]]]] ( def TotalSpend [[ :from :Order ] [ :agg [ :customer-id ] [ :total-spend [ rel/sum :total ]]]]) Sub queries with :$1 and :$ ;; $1 to sub select another row, i.e an implicit left-join. ( def CustomerStats [[ :from :Customer ] [ :extend [[ :total-spend ] [ :$1 TotalSpend { :customer-id :customer-id }]]]]) ;; would result in a relation something like: # {{ :customer 42 , :total-spend 340.0 M }} ;; $1 to bind rows from another query to a column ( def Order [[ :from :Order ] [ :extend [ :items [ :$ OrderItem { :order-id :order-id }]]]]) ;; would result in a relation something like: # {{ :customer-id 42 , :total 340.0 M :items # {{ :product-id 43 , :quantity 1 } ... }}","title":"Examples"},{"location":"extend/#see-also","text":":select :agg Unsafe transformation","title":"See also"},{"location":"fk/","text":":fk","title":":fk"},{"location":"fk/#fk","text":"","title":":fk"},{"location":"from/","text":":from :from is a statement of 1-arg, either a relvar or keyword (table), it performs no computation, and just flows rows from its argument to the next node in the relvar. ;; from a table [[ :from :A ]] ;; from another relvar [[ :from [[ :from :B ] [ :where [ = :foo 42 ]]]]]","title":":from"},{"location":"from/#from","text":":from is a statement of 1-arg, either a relvar or keyword (table), it performs no computation, and just flows rows from its argument to the next node in the relvar. ;; from a table [[ :from :A ]] ;; from another relvar [[ :from [[ :from :B ] [ :where [ = :foo 42 ]]]]]","title":":from"},{"location":"hash/","text":":hash","title":":hash"},{"location":"hash/#hash","text":"","title":":hash"},{"location":"indexes/","text":"Indexes","title":"Indexes"},{"location":"indexes/#indexes","text":"","title":"Indexes"},{"location":"insert/","text":":insert","title":":insert"},{"location":"insert/#insert","text":"","title":":insert"},{"location":"intersection/","text":":intersection Set intersection Examples [[ :intersection :a :b :c :d ]]","title":":intersection"},{"location":"intersection/#intersection","text":"Set intersection","title":":intersection"},{"location":"intersection/#examples","text":"[[ :intersection :a :b :c :d ]]","title":"Examples"},{"location":"join/","text":":join Joins two relations together, returning the product of matching rows. The columns in the relation on the right will be preferred in a conflict. Like set/join , clause is a map of expressions on the left to expressions on the right. Accepts both tables (keywords) and other relvars. Similar to an INNER JOIN in SQL. Form join = [ :join right clause & more ] right = relvar | table clause = { left-expr right-expr , ... } Examples [[ :from :Customer ] [ :join :Order { :id :customer-id }]]","title":":join"},{"location":"join/#join","text":"Joins two relations together, returning the product of matching rows. The columns in the relation on the right will be preferred in a conflict. Like set/join , clause is a map of expressions on the left to expressions on the right. Accepts both tables (keywords) and other relvars. Similar to an INNER JOIN in SQL.","title":":join"},{"location":"join/#form","text":"join = [ :join right clause & more ] right = relvar | table clause = { left-expr right-expr , ... }","title":"Form"},{"location":"join/#examples","text":"[[ :from :Customer ] [ :join :Order { :id :customer-id }]]","title":"Examples"},{"location":"left-join/","text":":left-join Like join but returns rows even if there are no matches in the right relation. Like SQL LEFT JOIN . Form left-join = [ :left-join right clause & more ] right = relvar | table clause = { left-expr right-expr , ... } Examples [[ :from :Customer ] ;; if orders are missing, you will get customer rows on their own [ :left-join :Order { :id :customer-id }]]","title":":left-join"},{"location":"left-join/#left-join","text":"Like join but returns rows even if there are no matches in the right relation. Like SQL LEFT JOIN .","title":":left-join"},{"location":"left-join/#form","text":"left-join = [ :left-join right clause & more ] right = relvar | table clause = { left-expr right-expr , ... }","title":"Form"},{"location":"left-join/#examples","text":"[[ :from :Customer ] ;; if orders are missing, you will get customer rows on their own [ :left-join :Order { :id :customer-id }]]","title":"Examples"},{"location":"lookup/","text":":lookup","title":":lookup"},{"location":"lookup/#lookup","text":"","title":":lookup"},{"location":"materialization/","text":"Materialization","title":"Materialization"},{"location":"materialization/#materialization","text":"","title":"Materialization"},{"location":"max-by/","text":"rel/max-by","title":"max-by"},{"location":"max-by/#relmax-by","text":"","title":"rel/max-by"},{"location":"max/","text":"max","title":"max"},{"location":"max/#max","text":"","title":"max"},{"location":"min-by/","text":"rel/min-by","title":"min-by"},{"location":"min-by/#relmin-by","text":"","title":"rel/min-by"},{"location":"min/","text":"min","title":"min"},{"location":"min/#min","text":"","title":"min"},{"location":"not-any/","text":"rel/not-any An aggregate that tests for all row in the group (pred row) returns falsey, accepts an expr as an arg. e.g ;; :has-no-a will be true if all rows have a falsey `:a` col [[ :from :A ] [ :agg [] [ :has-no-a [ rel/not-any :a ]]]","title":"not-any"},{"location":"not-any/#relnot-any","text":"An aggregate that tests for all row in the group (pred row) returns falsey, accepts an expr as an arg. e.g ;; :has-no-a will be true if all rows have a falsey `:a` col [[ :from :A ] [ :agg [] [ :has-no-a [ rel/not-any :a ]]]","title":"rel/not-any"},{"location":"qualify/","text":":qualify","title":":qualify"},{"location":"qualify/#qualify","text":"","title":":qualify"},{"location":"query/","text":"Query","title":"Issuing queries"},{"location":"query/#query","text":"","title":"Query"},{"location":"relvar/","text":"Relvar The data primitive in relic is the relvar, think of it like a SQL view, a description of some data made by combining tables, applying conditions, and computing columns and aggregates. A relvar is always a vector relvars are made up of statements, themselves vectors of the form [operator & args] . ;; example relvar from the tcp-h benchmark suite [[ :from :lineitem ] [ :where [ <= [ compare :l_shipdate # inst \"1998-09-02\" ] 0 ]] [ :agg [ :l_returnflag :l_linestatus ] [ :sum_qty [ rel/sum :l_quantity ]] [ :sum_base_price [ rel/sum :l_extendedprice ]] [ :sum_disc_price [ rel/sum [ * :l_extendedprice [ - 1 :l_discount ]]]] [ :sum_charge [ rel/sum [ * :l_extendedprice [ - 1 :l_discount ] [ + 1 :l_tax ]]]] [ :avg_qty [ rel/avg :l_quantity ]] [ :avg_price [ rel/avg :l_extendedprice ]] [ :avg_disc [ rel/avg :l_discount ]] [ :count_order count ]]] relvars compose by adding to the vector, this is in contrast to other approaches where query optimisers take care of the overall ordering. In relic, data always flows top-to-bottom. Although a relvar looks much like a query, you can also think of it as a view - and its super power is that relic allows you to materialize the relvar. This will convert the relvar into a DAG to support incremental re-computation as data in tables changes. With few exceptions (direct index lookup) you can materialize any relvar with rel/materialize . Rationale of form In the tar pit paper, the language used to express relvars was a traditional expression tree (e.g union(a, b) ). I wanted a data-first clojure dsl that met two goals, like any good data dsl I wanted to compose new relvars using regular clojure functions, and I wanted them to be easy to write and read as literals without ide support. The vector form I think is close to SQL, with a nice top-to-bottom reading flow. Each statement is self-contained in its own delimited form, and so you can create new relvars with conj , split them with split-at and so on. Query statements :from a.k.a start here :where to select only certain rows :join sql style relation inner join :left-join sql style relational left join :extend compute new columns :select project a subset of columns, computations :without drop columns :expand flatten nested sequences :agg apply aggregates over rows in groups :const provide a constant relation :difference set diff :intersection set intersection :union set union :rename rename columns :qualify qualify (namespace) columns Constraints :check ensure certain predicates hold :req ensure cols exist :fk ensure a referenced row exists in some other relvar :unique unsure only one row exists for some set of expressions :constrain combine multiple constraints on a relvar Indexes and direct index access :hash standard one-to-many hash index :btree standard one-to-many sorted index :lookup explicit index lookup","title":"Relvars"},{"location":"relvar/#relvar","text":"The data primitive in relic is the relvar, think of it like a SQL view, a description of some data made by combining tables, applying conditions, and computing columns and aggregates. A relvar is always a vector relvars are made up of statements, themselves vectors of the form [operator & args] . ;; example relvar from the tcp-h benchmark suite [[ :from :lineitem ] [ :where [ <= [ compare :l_shipdate # inst \"1998-09-02\" ] 0 ]] [ :agg [ :l_returnflag :l_linestatus ] [ :sum_qty [ rel/sum :l_quantity ]] [ :sum_base_price [ rel/sum :l_extendedprice ]] [ :sum_disc_price [ rel/sum [ * :l_extendedprice [ - 1 :l_discount ]]]] [ :sum_charge [ rel/sum [ * :l_extendedprice [ - 1 :l_discount ] [ + 1 :l_tax ]]]] [ :avg_qty [ rel/avg :l_quantity ]] [ :avg_price [ rel/avg :l_extendedprice ]] [ :avg_disc [ rel/avg :l_discount ]] [ :count_order count ]]] relvars compose by adding to the vector, this is in contrast to other approaches where query optimisers take care of the overall ordering. In relic, data always flows top-to-bottom. Although a relvar looks much like a query, you can also think of it as a view - and its super power is that relic allows you to materialize the relvar. This will convert the relvar into a DAG to support incremental re-computation as data in tables changes. With few exceptions (direct index lookup) you can materialize any relvar with rel/materialize .","title":"Relvar"},{"location":"relvar/#rationale-of-form","text":"In the tar pit paper, the language used to express relvars was a traditional expression tree (e.g union(a, b) ). I wanted a data-first clojure dsl that met two goals, like any good data dsl I wanted to compose new relvars using regular clojure functions, and I wanted them to be easy to write and read as literals without ide support. The vector form I think is close to SQL, with a nice top-to-bottom reading flow. Each statement is self-contained in its own delimited form, and so you can create new relvars with conj , split them with split-at and so on.","title":"Rationale of form"},{"location":"relvar/#query-statements","text":":from a.k.a start here :where to select only certain rows :join sql style relation inner join :left-join sql style relational left join :extend compute new columns :select project a subset of columns, computations :without drop columns :expand flatten nested sequences :agg apply aggregates over rows in groups :const provide a constant relation :difference set diff :intersection set intersection :union set union :rename rename columns :qualify qualify (namespace) columns","title":"Query statements"},{"location":"relvar/#constraints","text":":check ensure certain predicates hold :req ensure cols exist :fk ensure a referenced row exists in some other relvar :unique unsure only one row exists for some set of expressions :constrain combine multiple constraints on a relvar","title":"Constraints"},{"location":"relvar/#indexes-and-direct-index-access","text":":hash standard one-to-many hash index :btree standard one-to-many sorted index :lookup explicit index lookup","title":"Indexes and direct index access"},{"location":"rename/","text":":rename Renames columns, take a map of {old-col new-col, ...} as an arg.","title":":rename"},{"location":"rename/#rename","text":"Renames columns, take a map of {old-col new-col, ...} as an arg.","title":":rename"},{"location":"req/","text":":req","title":":req"},{"location":"req/#req","text":"","title":":req"},{"location":"select/","text":":select The projection statement, takes columns & extension style bindings and returns only them. Form select = [ :select & col-or-extension ] col-or-binding = col | [ binding expr ] Examples clojure [[:from :Customer] [:select :firstname :lastname [:fullname [str :firstname \" \" :lastname]]]]","title":":select"},{"location":"select/#select","text":"The projection statement, takes columns & extension style bindings and returns only them.","title":":select"},{"location":"select/#form","text":"select = [ :select & col-or-extension ] col-or-binding = col | [ binding expr ]","title":"Form"},{"location":"select/#examples","text":"clojure [[:from :Customer] [:select :firstname :lastname [:fullname [str :firstname \" \" :lastname]]]]","title":"Examples"},{"location":"set-concat/","text":"rel/set-concat","title":"set-concat"},{"location":"set-concat/#relset-concat","text":"","title":"rel/set-concat"},{"location":"sub-queries/","text":"Sub queries","title":"Sub queries"},{"location":"sub-queries/#sub-queries","text":"","title":"Sub queries"},{"location":"sum/","text":"rel/sum","title":"`rel/sum`"},{"location":"sum/#relsum","text":"","title":"rel/sum"},{"location":"terse-insert/","text":"Terser insert","title":"Terse Inserts"},{"location":"terse-insert/#terser-insert","text":"","title":"Terser insert"},{"location":"top-by/","text":"rel/top-by","title":"top-by"},{"location":"top-by/#reltop-by","text":"","title":"rel/top-by"},{"location":"top/","text":"rel/top","title":"top"},{"location":"top/#reltop","text":"","title":"rel/top"},{"location":"transact/","text":"Transact","title":"transact"},{"location":"transact/#transact","text":"","title":"Transact"},{"location":"union/","text":":union Set union Examples [[ :union :a :b :c :d ]]","title":":union"},{"location":"union/#union","text":"Set union","title":":union"},{"location":"union/#examples","text":"[[ :union :a :b :c :d ]]","title":"Examples"},{"location":"unique/","text":":unique","title":":unique"},{"location":"unique/#unique","text":"","title":":unique"},{"location":"unsafe-transform/","text":"Unsafe transformation","title":"Unsafe transforms"},{"location":"unsafe-transform/#unsafe-transformation","text":"","title":"Unsafe transformation"},{"location":"update/","text":":update","title":":update"},{"location":"update/#update","text":"","title":":update"},{"location":"upsert/","text":":upsert","title":":upsert"},{"location":"upsert/#upsert","text":"","title":":upsert"},{"location":"where/","text":":where Selects a subset of rows by applying predicate conditions to them before flowing onwards. Just like SQL WHERE . Form [ :where & expr ] See expression reference for information on expressions.","title":"`:where`"},{"location":"where/#where","text":"Selects a subset of rows by applying predicate conditions to them before flowing onwards. Just like SQL WHERE .","title":":where"},{"location":"where/#form","text":"[ :where & expr ] See expression reference for information on expressions.","title":"Form"},{"location":"without/","text":":without Removes columns, e.g like dissoc . Form [ :without & col ] Examples [[ :from :Customer ] [ :without :age :firstname :lastname ]]","title":"`:without`"},{"location":"without/#without","text":"Removes columns, e.g like dissoc .","title":":without"},{"location":"without/#form","text":"[ :without & col ]","title":"Form"},{"location":"without/#examples","text":"[[ :from :Customer ] [ :without :age :firstname :lastname ]]","title":"Examples"}]}